%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside]{article}

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\usepackage[sc]{mathpazo} % Use the Palatino font
% Output encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% Input encoding
\usepackage[utf8]{inputenc} % UTF-8 character encoding stuff
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{W.G. Puttenstein, R.L.H. Fontein, H.D. van Wieren, T. Kerkhoven: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

% Bibliography
\usepackage[backend=bibtex, sorting=none]{biblatex}
\bibliography{references.bib}

% Appendices
\usepackage[toc,page]{appendix} % appendix

% Additional column type
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\articletitle}{Comparison between Time Complexity of Different Color Refinement Algorithms in Graph Isomorphism}
\newcommand{\shorttitle}{Color Refinement Time Complexity in Graph Isomorphism}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Gerwin Puttenstein, Rick Fontein, Huub van Wieren, and Tim Kerkhoven}\\[2mm] % Your name
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:w.g.puttenstein@student.utwente.nl}{w.g.puttenstein@student.utwente.nl}, 
\href{mailto:r.l.h.fontein@student.utwente.nl}{r.l.h.fontein@student.utwente.nl},\\
\normalsize \href{mailto:h.d.vanwieren@student.utwente.nl}{h.d.vanwieren@student.utwente.nl},
\href{mailto:t.kerkhoven@student.utwente.nl}{t.kerkhoven@student.utwente.nl}% Your email addresses
}

\date{\today}

%----------------------------------------------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\begin{abstract}

\noindent This will be the abstract of the paper

\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\begin{multicols}{2} % Two-column layout throughout the main article text



%------------------------------------------------
\section{Introduction}
\label{intro}
This paper will compare the time complexity of two color refinement algorithms and confirm them with computational results. The first algorithm uses the color refinement algorithm as shown by J. de Jong\cite{presentation:slidesPartI}, while the other algorithm is based on DFA minimization as shown by P. Bonsma\cite{presentation:slidesPartIII}. The algorithms have been implemented and their computation times on test sets will be used to confirm the time complexity.

Color refinement algorithms are used in solving the graph isomorphism problem, which is the computational problem of determining whether two finite graphs are isomorphic. It is one of a very small number of problems belonging to NP neither known to be solvable in polynomial time nor NP-complete: it is one of 12 such problems listed by Garey \& Johnson (1979)\cite{book:gareyJohnson1979}, and the only one of that list whose complexity remains unresolved.\cite{website:wikiGI}

%------------------------------------------------
\section{Scope \& Objectives}
\label{scope}
The aim of this research paper is to calculate and compare the worst-case time complexity of both color refinement algorithms and verifying them using computational results. These results will be used to examine the differences in computation time between the algorithms for different types of graphs.

This paper will describe both algorithms, give the calculations for the asymptotic worst-case time complexity, as well as an examination of the computational results.
%------------------------------------------------
\section{Methods}
\label{methods}
%% WIP %%
The time complexity for both algorithms was calculated by hand. To verify the results, a computational experiment was performed. In this experiment, both algorithms were tested with various graphs from the test set.

The testing was all done on the same machine, under the same circumstances. Every test was performed at least three times in order to prevent outliers caused by external events.

\subsection{Testing}
\label{methods:testing}
In the experiment, both algorithms were tested with several sizes of the same type of graph, for various types of graphs. 
% TODO Insert method of testing here
Only the algorithms themselves were timed, initialization and other parts of the code were not included.

%------------------------------------------------
\section{Algorithms}
\label{algs}
%% TODO %%
% Describe algorithms, show concise calculations of time complexity
%%
For the paper, two different color refinement methods were implemented. The basic one gives all vertices in a graph with the same color but differently colored neighborhoods a separate color. This is done iteratively until the graph is stably colored. A coloring $\alpha$ of $G$ is stable if for all $u, v \in V(G)$ it holds that: if $\alpha(u) = \alpha(v)$, then $u$ and $v$ have identically colored neighborhoods. The problem with this method is that all vertices are checked each iteration. With fast color refinement the colors that lead to refinements are tracked. These colors are maintained in a queue. If a color class is being refined, the class is split into two different classes, with one class keeping the old color. The algorithm terminates with a stable color if no color class needs refinement in other words the queue is empty. The initial coloring is done in a separate algorithm before the color refinement algorithms take place and is therefore the same for both the fast and basic implementation.
Computing time of our algorithms are increasing by iterations over the vertices in a graph. To calculate the time complexity of the algorithms, the number of and the places of the iterations over the vertices are analyzed. In the basic implementation are several places where iterations over vertices take place. The code contains one main loop that takes worst case N iterations. So the time complexity so far is $O(\boldsymbol{N})$ In this main loop an iteration takes place over all the vertices in the graph. Time complexity is $O(N \cdot \boldsymbol{N})$ now. Each vertex is checked if it needs an update. If so, a new color dictionary is made and a new loop over the dictionary takes place. The time complexity is $O(N \cdot N \cdot \boldsymbol{N})$ for making the dictionary and gets $O((N \cdot N)(N+\boldsymbol{N}))$ for iterating over the dictionary. For each item in the dictionary is checked if the configuration already is assigned a new color. If the the configuration is not know yet, a new color is assigned. In worst case this new color operation costs again N. The time complexity is $O((N \cdot N)(N+N+\boldsymbol{N}))$ so far.
After the first loop over the vertices in the main loop, again the algorithm iterates over all the vertices to color all the vertices correctly in the main dictionary. The time complexity worst case at the end is $O((N \cdot (N+\boldsymbol{N})(N+N+N)) = O(N^3)$

%------------------------------------------------
\section{Results}
\label{results}
%% TODO %%
% Give and describe results
%%
% Table for results can be found at appendices


%------------------------------------------------
\section{Discussion} %Change section name?
\label{disc}
%% TODO %%
% Describe the effectiveness of the algorithms on various types of graphs, and examine the differences
%%

%------------------------------------------------
\section{Conclusions}
\label{concl}
%% TODO %%
% Draw conlusions from both the results and discussion
%%

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
\label{references}
\printbibliography
%bibliography{references}

%----------------------------------------------------------------------------------------
%	APPENDICES
%----------------------------------------------------------------------------------------
%% TODO %%
% Put all the things that should be in the paper, but don't fit the main part here
%%

% Everything EXCEPT multicols can be removed from the appendices if none are added.
\end{multicols}

\begin{appendices}
\label{app}

%------------------------------------------------
\section{Tables} %Change section name
\label{app:tab}
%% TODO %%
% Fill table with actual values
%%
%% NOTE %%
% All current values are fictional values for testing purposes only
%%
\begin{table}[h]\centering
\label{app:tab:0}
\begin{tabular}{|l|r@{.}l|r@{.}l|}
\hline
Graph	
	& \multicolumn{2}{l|}{Algorithm A \emph{(s)}}
	& \multicolumn{2}{l|}{Algorithm B \emph{(s)}} \\
\hline
graph\_{}type1\_{}16
	& 0	& 001
	& 0	& 005 \\
graph\_{}type1\_{}64
	& 0	& 1	
	& 0	& 1 \\
graph\_{}type1\_{}256
	& 10	& 0	
	& 2		& 0\\
graph\_{}type1\_{}1024
	& 1000	& 0 
	& 40	& 0 \\
graph\_{}type1\_{}4096
	& 100000	& 0
	& 800		& 0 \\
\hline
\end{tabular}
\caption{This is a table}
\end{table}
%------------------------------------------------

\end{appendices}
%----------------------------------------------------------------------------------------

\end{document}
